<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../mocha/mocha.js"></script>
    <script src="../../../chai/chai.js"></script>
    <script src="../../../wct-mocha/wct-mocha.js"></script>

  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <websocket-data-view></websocket-data-view>
      </template>
    </test-fixture>

    <script type="module">
    import '../websocket-data-view.js';
    import * as MockInteractions from '../../../@polymer/iron-test-helpers/mock-interactions.js';
    import {DataGenerator} from '../demo/data-generator.js';
    import sinon from '../../../sinon/pkg/sinon-esm.js';
    function getActionItem(item, element) {
      return element.shadowRoot.querySelector('[data-action="' + item + '"]');
    }
    suite('basic - no data', function() {
      let element;
      setup(function(done) {
        element = fixture('basic');
        flush(() => done());
      });

      test('hasMessages is not initially computed', function() {
        assert.isUndefined(element.hasMessages);
      });

      test('isSafari is computed', function() {
        assert.typeOf(element.isSafari, 'boolean');
      });

      test('Export button is not in the DOM', function() {
        const node = getActionItem('export-all', element);
        assert.notOk(node);
      });

      test('Clear button is not in the DOM', function() {
        const node = getActionItem('clear-all', element);
        assert.notOk(node);
      });
    });

    suite('basic - with data', function() {
      let element;
      setup(function(done) {
        element = fixture('basic');
        element.messages = DataGenerator.generateData(25);
        flush(() => done());
      });

      test('hasMessages is computed', function() {
        assert.isTrue(element.hasMessages);
      });

      test('Export button is in the DOM', function() {
        const node = getActionItem('export-all', element);
        assert.ok(node);
      });

      test('Clear button is in the DOM', function() {
        const node = getActionItem('clear-all', element);
        assert.ok(node);
      });

      test('Messages are rendered', function() {
        const nodes = element.shadowRoot.querySelectorAll('.table-values');
        assert.lengthOf(nodes, 25);
      });

      test('Clear button clears the messages', function(done) {
        const node = getActionItem('clear-all', element);
        MockInteractions.tap(node);
        flush(() => {
          assert.isUndefined(element.messages, 'Messages are cleared');
          assert.isFalse(element.hasMessages, 'hasMessages is false');
          const nodes = element.shadowRoot.querySelectorAll('.table-values');
          assert.lengthOf(nodes, 0, 'No messages are rendered');
          done();
        });
      });

      test('Clear button fires message-cleared event', function() {
        const spy = sinon.spy();
        element.addEventListener('message-cleared', spy);
        const node = getActionItem('clear-all', element);
        MockInteractions.tap(node);
        assert.isTrue(spy.calledOnce);
      });

      test('Export button fires export-data event', function() {
        const spy = sinon.spy();
        element.addEventListener('export-data', spy);
        const node = getActionItem('export-all', element);
        MockInteractions.tap(node);
        assert.isTrue(spy.calledOnce);
      });

      test('Not handled export-data event generates web file download', function() {
        if (element.isSafari) {
          return;
        }
        const node = getActionItem('export-all', element);
        MockInteractions.tap(node);
        assert.typeOf(element.downloadFileUrl, 'string', 'downloadFileUrl is set');
        assert.typeOf(element.downloadFileName, 'string', 'downloadFileName is set');
        const dialog = element.shadowRoot.querySelector('paper-dialog');
        assert.isTrue(dialog.opened, 'Save dialog is opened');
      });

      test('Closing save dialog clears the download data', function(done) {
        if (element.isSafari) {
          done();
          return;
        }
        const node = getActionItem('export-all', element);
        MockInteractions.tap(node);
        setTimeout(function() {
          const node = element.shadowRoot.querySelector('#saveDialog paper-button[dialog-dismiss]');
          MockInteractions.tap(node);
          setTimeout(function() {
            assert.isUndefined(element.downloadFileUrl, 'downloadFileUrl is cleared');
            assert.isUndefined(element.downloadFileName, 'downloadFileName is cleared');
            done();
          }, 300);
        }, 300);
      });
    });

    suite('_sortMessages()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Returns -1 when a.time is > b.time', () => {
        const result = element._sortMessages({time: 1}, {time: 0});
        assert.equal(result, -1);
      });

      test('Returns 1 when a.time is < b.time', () => {
        const result = element._sortMessages({time: 0}, {time: 1});
        assert.equal(result, 1);
      });

      test('Returns 0 otherwise', () => {
        const result = element._sortMessages({time: 1}, {time: 1});
        assert.equal(result, 0);
      });
    });

    suite('_getExportData()', function() {
      let element;
      setup(function() {
        element = fixture('basic');
        element.messages = DataGenerator.generateData(25);
        element.messages[0].isBinary = true;
      });

      test('Returns an array', () => {
        const result = element._getExportData();
        assert.typeOf(result, 'array');
      });

      test('Returns undefined when no data', () => {
        element.messages = undefined;
        const result = element._getExportData();
        assert.isUndefined(result);
      });

      test('Filters out binary messages', () => {
        const msg = element.messages[0].message;
        const result = element._getExportData();
        assert.notEqual(result.length, 25);
        assert.notEqual(result[0].message, msg);
      });
    });

    suite('_exportMessages()', function() {
      let element;
      setup(function(done) {
        element = fixture('basic');
        element.messages = DataGenerator.generateData(25);
        element.messages[0].isBinary = true;
        flush(() => done());
      });

      function exportHandler(e) {
        e.preventDefault();
      }

      suiteSetup(() => {
        window.addEventListener('export-data', exportHandler);
      });

      suiteTeardown(() => {
        window.removeEventListener('export-data', exportHandler);
      });

      test('Calls _exportMessages()', () => {
        const spy = sinon.spy(element, '_exportMessages');
        element._exportMessages();
        assert.isTrue(spy.called);
      });

      test('Calls _exportData() with arguments', () => {
        const spy = sinon.spy(element, '_exportData');
        element._exportMessages();
        assert.isTrue(spy.called);
        assert.typeOf(spy.args[0][0], 'array');
        assert.equal(spy.args[0][1], 'application/json');
      });

      test('Opens no data toast', () => {
        element.messages = undefined;
        element._exportMessages();
        assert.isTrue(element.$.noMessages.opened);
      });
    });

    suite('_downloadBinary()', () => {
      let element;
      setup(function(done) {
        element = fixture('basic');
        element.messages = DataGenerator.generateData(25);
        flush(() => done());
      });

      test('Calls _exportData() with arguments', () => {
        const spy = sinon.spy(element, '_exportData');
        const node = element.shadowRoot.querySelector('[data-action="export-binary"]');
        MockInteractions.tap(node);
        assert.isTrue(spy.called);
        assert.typeOf(spy.args[0][0], 'blob');
        assert.equal(spy.args[0][1], 'text/plain');
      });

      test('Sets default mime type', (done) => {
        element.messages.forEach((item, index) => {
          element.set('messages.' + index + '.isBinary', false);
        });
        element.set('messages.0.isBinary', true);
        element.set('messages.0.message', new Blob(['test']));
        flush(() => {
          const spy = sinon.spy(element, '_exportData');
          const node = element.shadowRoot.querySelector('[data-action="export-binary"]');
          MockInteractions.tap(node);
          assert.isTrue(spy.called);
          assert.typeOf(spy.args[0][0], 'blob');
          assert.equal(spy.args[0][1], 'application/octet-stream');
          done();
        });
      });
    });

    suite('_saveToFile()', () => {
      let element;
      setup(function() {
        element = fixture('basic');
      });

      test('Sets objecturl from a blob', () => {
        const data = new Blob(['test']);
        const mime = 'text/plain';
        element._saveToFile(data, mime);
        assert.typeOf(element.downloadFileUrl, 'string');
      });

      test('Sets file name from blob', () => {
        const data = new Blob(['test']);
        const mime = 'text/plain';
        element._saveToFile(data, mime);
        assert.typeOf(element.downloadFileName, 'string');
      });

      test('Sets .json extension for JSON mime', () => {
        const data = new Blob(['test']);
        const mime = 'application/json';
        element._saveToFile(data, mime);
        assert.notEqual(element.downloadFileName.indexOf('.json'), -1);
      });

      test('Sets .txt extension for plain text mime', () => {
        const data = new Blob(['test']);
        const mime = 'text/plain';
        element._saveToFile(data, mime);
        assert.notEqual(element.downloadFileName.indexOf('.txt'), -1);
      });
    });

    suite('_downloadIconTap()', () => {
      let element;
      setup(function() {
        element = fixture('basic');
        element.$.saveDialog.opened = true;
      });

      test('Closes the dialog', (done) => {
        element._downloadIconTap();
        setTimeout(() => {
          assert.isFalse(element.$.saveDialog.opened);
          done();
        }, 250);
      });
    });
    </script>

  </body>
</html>
